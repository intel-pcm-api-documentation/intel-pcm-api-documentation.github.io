<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>PCM Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classPCM-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PCM Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>CPU Performance Monitor.  
 <a href="classPCM.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cpucounters_8h_source.html">cpucounters.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPCM_1_1CustomCoreEventDescription.html">CustomCoreEventDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom Core event description.  <a href="structPCM_1_1CustomCoreEventDescription.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPCM_1_1ExtendedCustomCoreEventDescription.html">ExtendedCustomCoreEventDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended custom core event description.  <a href="structPCM_1_1ExtendedCustomCoreEventDescription.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0d4ffa4b31603643806e33b899719793"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d4ffa4b31603643806e33b899719793"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>MAX_C_STATE</b> = 10
 }</td></tr>
<tr class="separator:a0d4ffa4b31603643806e33b899719793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88584813a3ef51376efeb22928764786"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786">ProgramMode</a> { <a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786a0e861144f482697cfa423b012ed42451">DEFAULT_EVENTS</a> = 0, 
<a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786ac092b2b5f351e33046b87e5cee31f38f">CUSTOM_CORE_EVENTS</a> = 1, 
<a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786a0f2ff80b85b8f9483c7f03544f73fcbd">EXT_CUSTOM_CORE_EVENTS</a> = 2, 
<a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786ad60e2f3b64e27eaaa84d2b07fea8e225">INVALID_MODE</a>
 }</td></tr>
<tr class="memdesc:a88584813a3ef51376efeb22928764786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mode of programming (parameter in the <a class="el" href="classPCM.html#a814c0ec41ba297581243e9c539bd38e5" title="Programs performance counters. ">program()</a> method)  <a href="classPCM.html#a88584813a3ef51376efeb22928764786">More...</a><br /></td></tr>
<tr class="separator:a88584813a3ef51376efeb22928764786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebf5f22d794719dfc49155741e264e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abebf5f22d794719dfc49155741e264e5"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#abebf5f22d794719dfc49155741e264e5">ErrorCode</a> { <b>Success</b> = 0, 
<b>MSRAccessDenied</b> = 1, 
<b>PMUBusy</b> = 2, 
<b>UnknownError</b>
 }</td></tr>
<tr class="memdesc:abebf5f22d794719dfc49155741e264e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return codes (e.g. for program(..) method) <br /></td></tr>
<tr class="separator:abebf5f22d794719dfc49155741e264e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca50e5907ef2b7cf7c81a5e069135f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ca50e5907ef2b7cf7c81a5e069135f7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a7ca50e5907ef2b7cf7c81a5e069135f7">SupportedCPUModels</a> { <br />
&#160;&#160;<b>NEHALEM_EP</b> = 26, 
<b>NEHALEM</b> = 30, 
<b>ATOM</b> = 28, 
<b>ATOM_2</b> = 53, 
<br />
&#160;&#160;<b>ATOM_CENTERTON</b> = 54, 
<b>ATOM_BAYTRAIL</b> = 55, 
<b>ATOM_AVOTON</b> = 77, 
<b>CLARKDALE</b> = 37, 
<br />
&#160;&#160;<b>WESTMERE_EP</b> = 44, 
<b>NEHALEM_EX</b> = 46, 
<b>WESTMERE_EX</b> = 47, 
<b>SANDY_BRIDGE</b> = 42, 
<br />
&#160;&#160;<b>JAKETOWN</b> = 45, 
<b>IVY_BRIDGE</b> = 58, 
<b>HASWELL</b> = 60, 
<b>HASWELL_ULT</b> = 69, 
<br />
&#160;&#160;<b>HASWELL_2</b> = 70, 
<b>IVYTOWN</b> = 62, 
<b>END_OF_MODEL_LIST</b>
<br />
 }</td></tr>
<tr class="memdesc:a7ca50e5907ef2b7cf7c81a5e069135f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifiers of supported CPU models. <br /></td></tr>
<tr class="separator:a7ca50e5907ef2b7cf7c81a5e069135f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b8031a61ae839bdd021ee7b56aa585"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77b8031a61ae839bdd021ee7b56aa585"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PCIeEventCode</b> { <br />
&#160;&#160;<b>PCIePRd</b> = 0x195, 
<b>PCIeRdCur</b> = 0x19E, 
<b>PCIeNSRd</b> = 0x1E4, 
<b>PCIeWiLF</b> = 0x194, 
<br />
&#160;&#160;<b>PCIeItoM</b> = 0x19C, 
<b>PCIeNSWr</b> = 0x1E5, 
<b>PCIeNSWrF</b> = 0x1E6
<br />
 }</td></tr>
<tr class="separator:a77b8031a61ae839bdd021ee7b56aa585"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af43f3a1e920264467a3855ced5f8162b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af43f3a1e920264467a3855ced5f8162b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#af43f3a1e920264467a3855ced5f8162b">isCoreCStateResidencySupported</a> (int state)</td></tr>
<tr class="memdesc:af43f3a1e920264467a3855ced5f8162b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified core C-state residency metric is supported. <br /></td></tr>
<tr class="separator:af43f3a1e920264467a3855ced5f8162b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad05d8a2f383ad41d25892175373b613"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad05d8a2f383ad41d25892175373b613"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#aad05d8a2f383ad41d25892175373b613">isPackageCStateResidencySupported</a> (int state)</td></tr>
<tr class="memdesc:aad05d8a2f383ad41d25892175373b613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified package C-state residency metric is supported. <br /></td></tr>
<tr class="separator:aad05d8a2f383ad41d25892175373b613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56eedaa84893f72b1723f8d580ee3329"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a56eedaa84893f72b1723f8d580ee3329">good</a> ()</td></tr>
<tr class="memdesc:a56eedaa84893f72b1723f8d580ee3329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the status of <a class="el" href="classPCM.html" title="CPU Performance Monitor. ">PCM</a> object.  <a href="#a56eedaa84893f72b1723f8d580ee3329">More...</a><br /></td></tr>
<tr class="separator:a56eedaa84893f72b1723f8d580ee3329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ce6762ad3607dbb839b6698f94697a"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ae7ce6762ad3607dbb839b6698f94697a">getErrorMessage</a> () const </td></tr>
<tr class="memdesc:ae7ce6762ad3607dbb839b6698f94697a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error message.  <a href="#ae7ce6762ad3607dbb839b6698f94697a">More...</a><br /></td></tr>
<tr class="separator:ae7ce6762ad3607dbb839b6698f94697a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814c0ec41ba297581243e9c539bd38e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPCM.html#abebf5f22d794719dfc49155741e264e5">ErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a814c0ec41ba297581243e9c539bd38e5">program</a> (<a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786">ProgramMode</a> mode_=<a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786a0e861144f482697cfa423b012ed42451">DEFAULT_EVENTS</a>, void *parameter_=NULL)</td></tr>
<tr class="memdesc:a814c0ec41ba297581243e9c539bd38e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs performance counters.  <a href="#a814c0ec41ba297581243e9c539bd38e5">More...</a><br /></td></tr>
<tr class="separator:a814c0ec41ba297581243e9c539bd38e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a30cec6e4e7a78ec964d194e3844637"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPCM.html#abebf5f22d794719dfc49155741e264e5">ErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a3a30cec6e4e7a78ec964d194e3844637">programServerUncorePowerMetrics</a> (int mc_profile, int pcu_profile, int *freq_bands=NULL)</td></tr>
<tr class="memdesc:a3a30cec6e4e7a78ec964d194e3844637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs uncore power/energy counters on microarchitectures codename SandyBridge-EP and IvyTown.  <a href="#a3a30cec6e4e7a78ec964d194e3844637">More...</a><br /></td></tr>
<tr class="separator:a3a30cec6e4e7a78ec964d194e3844637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f142010bb99ba6b81e93895bfa20252"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f142010bb99ba6b81e93895bfa20252"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a9f142010bb99ba6b81e93895bfa20252">freezeServerUncoreCounters</a> ()</td></tr>
<tr class="memdesc:a9f142010bb99ba6b81e93895bfa20252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Freezes uncore event counting (works only on microarchitecture codename SandyBridge-EP and IvyTown) <br /></td></tr>
<tr class="separator:a9f142010bb99ba6b81e93895bfa20252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617beda55da4de32593a7aa925fe1f02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a617beda55da4de32593a7aa925fe1f02"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a617beda55da4de32593a7aa925fe1f02">unfreezeServerUncoreCounters</a> ()</td></tr>
<tr class="memdesc:a617beda55da4de32593a7aa925fe1f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unfreezes uncore event counting (works only on microarchitecture codename SandyBridge-EP and IvyTown) <br /></td></tr>
<tr class="separator:a617beda55da4de32593a7aa925fe1f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db0d472d9cdc0aa3c6db8ed7bb38f77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classServerUncorePowerState.html">ServerUncorePowerState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a9db0d472d9cdc0aa3c6db8ed7bb38f77">getServerUncorePowerState</a> (uint32 socket)</td></tr>
<tr class="memdesc:a9db0d472d9cdc0aa3c6db8ed7bb38f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the power/energy counter state of a socket (works only on microarchitecture codename SandyBridge-EP)  <a href="#a9db0d472d9cdc0aa3c6db8ed7bb38f77">More...</a><br /></td></tr>
<tr class="separator:a9db0d472d9cdc0aa3c6db8ed7bb38f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c8d3764ff95840ece17d632de4df9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ac0c8d3764ff95840ece17d632de4df9b">cleanup</a> ()</td></tr>
<tr class="memdesc:ac0c8d3764ff95840ece17d632de4df9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanups resources and stops performance counting.  <a href="#ac0c8d3764ff95840ece17d632de4df9b">More...</a><br /></td></tr>
<tr class="separator:ac0c8d3764ff95840ece17d632de4df9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f5ff2c6ce12f0fb4bb5ae1e5bd157a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ad4f5ff2c6ce12f0fb4bb5ae1e5bd157a">resetPMU</a> ()</td></tr>
<tr class="memdesc:ad4f5ff2c6ce12f0fb4bb5ae1e5bd157a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces PMU reset.  <a href="#ad4f5ff2c6ce12f0fb4bb5ae1e5bd157a">More...</a><br /></td></tr>
<tr class="separator:ad4f5ff2c6ce12f0fb4bb5ae1e5bd157a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade92d30321a659ca54d423eaf0e30e12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ade92d30321a659ca54d423eaf0e30e12">getAllCounterStates</a> (<a class="el" href="classSystemCounterState.html">SystemCounterState</a> &amp;systemState, std::vector&lt; <a class="el" href="classSocketCounterState.html">SocketCounterState</a> &gt; &amp;socketStates, std::vector&lt; <a class="el" href="classCoreCounterState.html">CoreCounterState</a> &gt; &amp;coreStates)</td></tr>
<tr class="memdesc:ade92d30321a659ca54d423eaf0e30e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads all counter states (including system, sockets and cores)  <a href="#ade92d30321a659ca54d423eaf0e30e12">More...</a><br /></td></tr>
<tr class="separator:ade92d30321a659ca54d423eaf0e30e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603bf92fb67f294f5bc59185bc5c89cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSystemCounterState.html">SystemCounterState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a603bf92fb67f294f5bc59185bc5c89cb">getSystemCounterState</a> ()</td></tr>
<tr class="memdesc:a603bf92fb67f294f5bc59185bc5c89cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the counter state of the system.  <a href="#a603bf92fb67f294f5bc59185bc5c89cb">More...</a><br /></td></tr>
<tr class="separator:a603bf92fb67f294f5bc59185bc5c89cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade00dbbd2a71ec32ae6747bfca66cd3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSocketCounterState.html">SocketCounterState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ade00dbbd2a71ec32ae6747bfca66cd3c">getSocketCounterState</a> (uint32 socket)</td></tr>
<tr class="memdesc:ade00dbbd2a71ec32ae6747bfca66cd3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the counter state of a socket.  <a href="#ade00dbbd2a71ec32ae6747bfca66cd3c">More...</a><br /></td></tr>
<tr class="separator:ade00dbbd2a71ec32ae6747bfca66cd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed1c64e3cb00c76851e3373a1fa54a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCoreCounterState.html">CoreCounterState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a4ed1c64e3cb00c76851e3373a1fa54a3">getCoreCounterState</a> (uint32 core)</td></tr>
<tr class="memdesc:a4ed1c64e3cb00c76851e3373a1fa54a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the counter state of a (logical) core.  <a href="#a4ed1c64e3cb00c76851e3373a1fa54a3">More...</a><br /></td></tr>
<tr class="separator:a4ed1c64e3cb00c76851e3373a1fa54a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14572fb187f2c0121843fb50f886ebd"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ad14572fb187f2c0121843fb50f886ebd">getNumCores</a> ()</td></tr>
<tr class="memdesc:ad14572fb187f2c0121843fb50f886ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads number of logical cores in the system.  <a href="#ad14572fb187f2c0121843fb50f886ebd">More...</a><br /></td></tr>
<tr class="separator:ad14572fb187f2c0121843fb50f886ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1c78309aae01a2706d1fc39766e90f"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a5e1c78309aae01a2706d1fc39766e90f">getNumSockets</a> ()</td></tr>
<tr class="memdesc:a5e1c78309aae01a2706d1fc39766e90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads number of sockets (CPUs) in the system.  <a href="#a5e1c78309aae01a2706d1fc39766e90f">More...</a><br /></td></tr>
<tr class="separator:a5e1c78309aae01a2706d1fc39766e90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad049657e9c017c4b5840f36958b1f1"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#aaad049657e9c017c4b5840f36958b1f1">getThreadsPerCore</a> ()</td></tr>
<tr class="memdesc:aaad049657e9c017c4b5840f36958b1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads how many hardware threads has a physical core "Hardware thread" is a logical core in a different terminology. If Intel(r) Hyperthreading(tm) is enabled then this function returns 2.  <a href="#aaad049657e9c017c4b5840f36958b1f1">More...</a><br /></td></tr>
<tr class="separator:aaad049657e9c017c4b5840f36958b1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb1bbca3a6ddce86dbbf8c944216710"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a3cb1bbca3a6ddce86dbbf8c944216710">getSMT</a> ()</td></tr>
<tr class="memdesc:a3cb1bbca3a6ddce86dbbf8c944216710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if SMT (HyperThreading) is enabled.  <a href="#a3cb1bbca3a6ddce86dbbf8c944216710">More...</a><br /></td></tr>
<tr class="separator:a3cb1bbca3a6ddce86dbbf8c944216710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826a1f946b8a8d461a25ea7d11f8646e"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a826a1f946b8a8d461a25ea7d11f8646e">getNominalFrequency</a> ()</td></tr>
<tr class="memdesc:a826a1f946b8a8d461a25ea7d11f8646e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the nominal core frequency.  <a href="#a826a1f946b8a8d461a25ea7d11f8646e">More...</a><br /></td></tr>
<tr class="separator:a826a1f946b8a8d461a25ea7d11f8646e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae797dcf2d4162a37a3535dd5aa48f87f"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ae797dcf2d4162a37a3535dd5aa48f87f">getCPUModel</a> ()</td></tr>
<tr class="memdesc:ae797dcf2d4162a37a3535dd5aa48f87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads CPU model id.  <a href="#ae797dcf2d4162a37a3535dd5aa48f87f">More...</a><br /></td></tr>
<tr class="separator:ae797dcf2d4162a37a3535dd5aa48f87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe7e00fc21589083988d3f1f7b0ade3"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#abfe7e00fc21589083988d3f1f7b0ade3">getOriginalCPUModel</a> ()</td></tr>
<tr class="memdesc:abfe7e00fc21589083988d3f1f7b0ade3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads original CPU model id.  <a href="#abfe7e00fc21589083988d3f1f7b0ade3">More...</a><br /></td></tr>
<tr class="separator:abfe7e00fc21589083988d3f1f7b0ade3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf36e7c9584fc5634f190cb79ef6468"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a3cf36e7c9584fc5634f190cb79ef6468">getSocketId</a> (uint32 core_id)</td></tr>
<tr class="memdesc:a3cf36e7c9584fc5634f190cb79ef6468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines socket of given core.  <a href="#a3cf36e7c9584fc5634f190cb79ef6468">More...</a><br /></td></tr>
<tr class="separator:a3cf36e7c9584fc5634f190cb79ef6468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf164b6843e71199d6c26544df108799"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#acf164b6843e71199d6c26544df108799">getQPILinksPerSocket</a> () const </td></tr>
<tr class="memdesc:acf164b6843e71199d6c26544df108799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of Intel(r) Quick Path Interconnect(tm) links per socket.  <a href="#acf164b6843e71199d6c26544df108799">More...</a><br /></td></tr>
<tr class="separator:acf164b6843e71199d6c26544df108799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f04203c6bef6f9fcdf489c6fea9089"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57f04203c6bef6f9fcdf489c6fea9089"></a>
uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a57f04203c6bef6f9fcdf489c6fea9089">getMCPerSocket</a> () const </td></tr>
<tr class="memdesc:a57f04203c6bef6f9fcdf489c6fea9089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of detected integrated memory controllers per socket. <br /></td></tr>
<tr class="separator:a57f04203c6bef6f9fcdf489c6fea9089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa034407ccfd9901b40a64bc29ffb467a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa034407ccfd9901b40a64bc29ffb467a"></a>
uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#aa034407ccfd9901b40a64bc29ffb467a">getMCChannelsPerSocket</a> () const </td></tr>
<tr class="memdesc:aa034407ccfd9901b40a64bc29ffb467a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of detected memory channels on all integrated memory controllers per socket. <br /></td></tr>
<tr class="separator:aa034407ccfd9901b40a64bc29ffb467a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5450e5ce7c995410d7ac7e6e1cb1a4"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a5e5450e5ce7c995410d7ac7e6e1cb1a4">getMaxIPC</a> () const </td></tr>
<tr class="memdesc:a5e5450e5ce7c995410d7ac7e6e1cb1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the max number of instructions per cycle.  <a href="#a5e5450e5ce7c995410d7ac7e6e1cb1a4">More...</a><br /></td></tr>
<tr class="separator:a5e5450e5ce7c995410d7ac7e6e1cb1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794f5852662a2827b34eb16025564c70"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a794f5852662a2827b34eb16025564c70">getTickCount</a> (uint64 multiplier=1000, uint32 core=0)</td></tr>
<tr class="memdesc:a794f5852662a2827b34eb16025564c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TSC timer value in time units.  <a href="#a794f5852662a2827b34eb16025564c70">More...</a><br /></td></tr>
<tr class="separator:a794f5852662a2827b34eb16025564c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5153c7ec05003da7d20aeea737113e"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a0d5153c7ec05003da7d20aeea737113e">getTickCountRDTSCP</a> (uint64 multiplier=1000)</td></tr>
<tr class="memdesc:a0d5153c7ec05003da7d20aeea737113e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TSC timer value in time units using rdtscp instruction from current core.  <a href="#a0d5153c7ec05003da7d20aeea737113e">More...</a><br /></td></tr>
<tr class="separator:a0d5153c7ec05003da7d20aeea737113e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36f29c354d85562d0492cc6688dc219"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ab36f29c354d85562d0492cc6688dc219">getQPILinkSpeed</a> () const </td></tr>
<tr class="memdesc:ab36f29c354d85562d0492cc6688dc219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return QPI Link Speed in GBytes/second.  <a href="#ab36f29c354d85562d0492cc6688dc219">More...</a><br /></td></tr>
<tr class="separator:ab36f29c354d85562d0492cc6688dc219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ed5d9b2caa55615bc9b6c4e65eccb4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81ed5d9b2caa55615bc9b6c4e65eccb4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a81ed5d9b2caa55615bc9b6c4e65eccb4">getJoulesPerEnergyUnit</a> () const </td></tr>
<tr class="memdesc:a81ed5d9b2caa55615bc9b6c4e65eccb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many joules are in an internal processor energy unit. <br /></td></tr>
<tr class="separator:a81ed5d9b2caa55615bc9b6c4e65eccb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1e83a12ad11bbefde28ef0363e2663"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a1e83a12ad11bbefde28ef0363e2663"></a>
int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a6a1e83a12ad11bbefde28ef0363e2663">getPackageThermalSpecPower</a> () const </td></tr>
<tr class="memdesc:a6a1e83a12ad11bbefde28ef0363e2663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns thermal specification power of the package domain in Watt. <br /></td></tr>
<tr class="separator:a6a1e83a12ad11bbefde28ef0363e2663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa93f0a086f91b63c9a3f5375ef2f07"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1aa93f0a086f91b63c9a3f5375ef2f07"></a>
int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a1aa93f0a086f91b63c9a3f5375ef2f07">getPackageMinimumPower</a> () const </td></tr>
<tr class="memdesc:a1aa93f0a086f91b63c9a3f5375ef2f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns minimum power derived from electrical spec of the package domain in Watt. <br /></td></tr>
<tr class="separator:a1aa93f0a086f91b63c9a3f5375ef2f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f649340620d5ca7514d26861d9d79a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f649340620d5ca7514d26861d9d79a4"></a>
int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a8f649340620d5ca7514d26861d9d79a4">getPackageMaximumPower</a> () const </td></tr>
<tr class="memdesc:a8f649340620d5ca7514d26861d9d79a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns maximum power derived from electrical spec of the package domain in Watt. <br /></td></tr>
<tr class="separator:a8f649340620d5ca7514d26861d9d79a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb695430e52dcf00adab2aa270f0cb11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb695430e52dcf00adab2aa270f0cb11"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>disableJKTWorkaround</b> ()</td></tr>
<tr class="separator:abb695430e52dcf00adab2aa270f0cb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08856dbb248f1a35a9c49799490f1734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a08856dbb248f1a35a9c49799490f1734">programPCIeCounters</a> (const PCIeEventCode event_)</td></tr>
<tr class="memdesc:a08856dbb248f1a35a9c49799490f1734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program uncore PCIe monitoring event(s)  <a href="#a08856dbb248f1a35a9c49799490f1734">More...</a><br /></td></tr>
<tr class="separator:a08856dbb248f1a35a9c49799490f1734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1b549672af4c14c00eb7d461c87ac4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPCIeCounterState.html">PCIeCounterState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a3b1b549672af4c14c00eb7d461c87ac4">getPCIeCounterState</a> (const uint32 socket_)</td></tr>
<tr class="memdesc:a3b1b549672af4c14c00eb7d461c87ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the state of PCIe counter(s)  <a href="#a3b1b549672af4c14c00eb7d461c87ac4">More...</a><br /></td></tr>
<tr class="separator:a3b1b549672af4c14c00eb7d461c87ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe37e4fcbf856df75c9fbdd83d9054a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe37e4fcbf856df75c9fbdd83d9054a1"></a>
uint64&#160;</td><td class="memItemRight" valign="bottom"><b>extractCoreGenCounterValue</b> (uint64 val)</td></tr>
<tr class="separator:abe37e4fcbf856df75c9fbdd83d9054a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efedba414c4b01207e6d57dc83dd66a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9efedba414c4b01207e6d57dc83dd66a"></a>
uint64&#160;</td><td class="memItemRight" valign="bottom"><b>extractCoreFixedCounterValue</b> (uint64 val)</td></tr>
<tr class="separator:a9efedba414c4b01207e6d57dc83dd66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad9ccfca970ae03229377926df029cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abad9ccfca970ae03229377926df029cc"></a>
uint64&#160;</td><td class="memItemRight" valign="bottom"><b>extractUncoreGenCounterValue</b> (uint64 val)</td></tr>
<tr class="separator:abad9ccfca970ae03229377926df029cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea22c144bd0a0a2c2672b49b0ad5a5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ea22c144bd0a0a2c2672b49b0ad5a5b"></a>
uint64&#160;</td><td class="memItemRight" valign="bottom"><b>extractUncoreFixedCounterValue</b> (uint64 val)</td></tr>
<tr class="separator:a8ea22c144bd0a0a2c2672b49b0ad5a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ed1104b141f47b01b722a990eb4233"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2ed1104b141f47b01b722a990eb4233"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#ab2ed1104b141f47b01b722a990eb4233">getUArchCodename</a> ()</td></tr>
<tr class="memdesc:ab2ed1104b141f47b01b722a990eb4233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string describing the codename of the processor microarchitecture. <br /></td></tr>
<tr class="separator:ab2ed1104b141f47b01b722a990eb4233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7eeb5ea9e2c73642d145097f0698b89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7eeb5ea9e2c73642d145097f0698b89"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>packageEnergyMetricsAvailable</b> () const </td></tr>
<tr class="separator:af7eeb5ea9e2c73642d145097f0698b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90d28db362a1a4383bbad41df25fc72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af90d28db362a1a4383bbad41df25fc72"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>dramEnergyMetricsAvailable</b> () const </td></tr>
<tr class="separator:af90d28db362a1a4383bbad41df25fc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a536dfa2028c638994075d40f4f0b5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a536dfa2028c638994075d40f4f0b5b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>packageThermalMetricsAvailable</b> () const </td></tr>
<tr class="separator:a3a536dfa2028c638994075d40f4f0b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fa349cb308ae6ca5fc45295ee7d070"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48fa349cb308ae6ca5fc45295ee7d070"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>outgoingQPITrafficMetricsAvailable</b> () const </td></tr>
<tr class="separator:a48fa349cb308ae6ca5fc45295ee7d070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886148633bec07ab47d507cd00647814"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a886148633bec07ab47d507cd00647814"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>qpiUtilizationMetricsAvailable</b> () const </td></tr>
<tr class="separator:a886148633bec07ab47d507cd00647814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0805f3a054ed1964bdf83e7f18f179f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0805f3a054ed1964bdf83e7f18f179f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>memoryTrafficMetricsAvailable</b> () const </td></tr>
<tr class="separator:ab0805f3a054ed1964bdf83e7f18f179f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa160fedc93e77c70bef9a1c8a89970d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa160fedc93e77c70bef9a1c8a89970d9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasBecktonUncore</b> () const </td></tr>
<tr class="separator:aa160fedc93e77c70bef9a1c8a89970d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e4f2a2b4a98960acae369fd3911498"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9e4f2a2b4a98960acae369fd3911498"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasPCICFGUncore</b> () const </td></tr>
<tr class="separator:ad9e4f2a2b4a98960acae369fd3911498"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a155611028fb95409625e44784f7b4c7b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classPCM.html">PCM</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a155611028fb95409625e44784f7b4c7b">getInstance</a> ()</td></tr>
<tr class="memdesc:a155611028fb95409625e44784f7b4c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <a class="el" href="classPCM.html" title="CPU Performance Monitor. ">PCM</a> object.  <a href="#a155611028fb95409625e44784f7b4c7b">More...</a><br /></td></tr>
<tr class="separator:a155611028fb95409625e44784f7b4c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4cabfe4223f1d2e7e1e0da8b1179b3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a5e4cabfe4223f1d2e7e1e0da8b1179b3">initWinRing0Lib</a> ()</td></tr>
<tr class="memdesc:a5e4cabfe4223f1d2e7e1e0da8b1179b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads and initializes Winring0 third party library for access to processor model specific and PCI configuration registers.  <a href="#a5e4cabfe4223f1d2e7e1e0da8b1179b3">More...</a><br /></td></tr>
<tr class="separator:a5e4cabfe4223f1d2e7e1e0da8b1179b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3279d88bbd5c2eab06c9c6cb6248c3c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3279d88bbd5c2eab06c9c6cb6248c3c7"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPCM.html#a3279d88bbd5c2eab06c9c6cb6248c3c7">getCPUBrandString</a> ()</td></tr>
<tr class="memdesc:a3279d88bbd5c2eab06c9c6cb6248c3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Brand string of processor. <br /></td></tr>
<tr class="separator:a3279d88bbd5c2eab06c9c6cb6248c3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ae338fe587ce44ca6801b2f280dd87b25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae338fe587ce44ca6801b2f280dd87b25"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>BasicCounterState</b></td></tr>
<tr class="separator:ae338fe587ce44ca6801b2f280dd87b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a2644b6d84c756de9746c1cf1ed68e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50a2644b6d84c756de9746c1cf1ed68e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>UncoreCounterState</b></td></tr>
<tr class="separator:a50a2644b6d84c756de9746c1cf1ed68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>CPU Performance Monitor. </p>
<p>This singleton object needs to be instantiated for each process before accessing counting and measuring routines </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a88584813a3ef51376efeb22928764786"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786">PCM::ProgramMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mode of programming (parameter in the <a class="el" href="classPCM.html#a814c0ec41ba297581243e9c539bd38e5" title="Programs performance counters. ">program()</a> method) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a88584813a3ef51376efeb22928764786a0e861144f482697cfa423b012ed42451"></a>DEFAULT_EVENTS&#160;</td><td class="fielddoc">
<p>Default choice of events, the additional parameter is not needed and ignored </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a88584813a3ef51376efeb22928764786ac092b2b5f351e33046b87e5cee31f38f"></a>CUSTOM_CORE_EVENTS&#160;</td><td class="fielddoc">
<p>Custom set of core events specified in the parameter to the program method. The parameter must be a pointer to array of four <code><a class="el" href="structPCM_1_1CustomCoreEventDescription.html" title="Custom Core event description. ">CustomCoreEventDescription</a></code> values </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a88584813a3ef51376efeb22928764786a0f2ff80b85b8f9483c7f03544f73fcbd"></a>EXT_CUSTOM_CORE_EVENTS&#160;</td><td class="fielddoc">
<p>Custom set of core events specified in the parameter to the program method. The parameter must be a pointer to a <code><a class="el" href="structPCM_1_1ExtendedCustomCoreEventDescription.html" title="Extended custom core event description. ">ExtendedCustomCoreEventDescription</a></code> data structure </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a88584813a3ef51376efeb22928764786ad60e2f3b64e27eaaa84d2b07fea8e225"></a>INVALID_MODE&#160;</td><td class="fielddoc">
<p>Non-programmed mode </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac0c8d3764ff95840ece17d632de4df9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM::cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleanups resources and stops performance counting. </p>
<p>One needs to call this method when your program finishes or/and you are not going to use the performance counting routines anymore. </p>

</div>
</div>
<a class="anchor" id="ade92d30321a659ca54d423eaf0e30e12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM::getAllCounterStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSystemCounterState.html">SystemCounterState</a> &amp;&#160;</td>
          <td class="paramname"><em>systemState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSocketCounterState.html">SocketCounterState</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>socketStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classCoreCounterState.html">CoreCounterState</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coreStates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads all counter states (including system, sockets and cores) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">systemState</td><td>system counter state (return parameter) </td></tr>
    <tr><td class="paramname">socketStates</td><td>socket counter states (return parameter) </td></tr>
    <tr><td class="paramname">coreStates</td><td>core counter states (return parameter) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ed1c64e3cb00c76851e3373a1fa54a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCoreCounterState.html">CoreCounterState</a> PCM::getCoreCounterState </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>core</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the counter state of a (logical) core. </p>
<p>Be aware that during the measurement other threads may be scheduled on the same core by the operating system (this is called context-switching). The performance events caused by these threads will be counted as well.</p>
<pre class="fragment">\param core core id
\return State of counters in the core</pre> 
<p>Referenced by <a class="el" href="cpucounters_8h.html#a3641dfa6466049072b8937ee64b03738">getCoreCounterState()</a>, and <a class="el" href="classPCM.html#a794f5852662a2827b34eb16025564c70">getTickCount()</a>.</p>

</div>
</div>
<a class="anchor" id="ae797dcf2d4162a37a3535dd5aa48f87f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PCM::getCPUModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads CPU model id. </p>
<dl class="section return"><dt>Returns</dt><dd>CPU model ID </dd></dl>

<p>Referenced by <a class="el" href="cpucounters_8h.html#ac26765efe8a4c7341f40c8ab8bdb9af6">getCyclesLostDueL2CacheMisses()</a>, <a class="el" href="cpucounters_8h.html#a89d4cef9c83db7e76be6a0a2e7351e2e">getCyclesLostDueL3CacheMisses()</a>, <a class="el" href="cpucounters_8h.html#a5922acedeec3c1cc67d20670f8ef0518">getL2CacheHitRatio()</a>, <a class="el" href="cpucounters_8h.html#a459367d7877d09594c2ecd85e04cae61">getL2CacheHits()</a>, <a class="el" href="cpucounters_8h.html#a291eeab262fdb93de08cdfdf50dbad58">getL2CacheMisses()</a>, <a class="el" href="cpucounters_8h.html#a7b03f0cd02862716d717e897032b7885">getL3CacheHitRatio()</a>, <a class="el" href="cpucounters_8h.html#a7ba16714ef7ed547ad8648cb5b9e52f6">getL3CacheHits()</a>, <a class="el" href="cpucounters_8h.html#ace0e3ffc23c20d0eda7663cb7e4899a2">getL3CacheHitsNoSnoop()</a>, <a class="el" href="cpucounters_8h.html#a4b1050ca9ccdd66661df556bab70fd0f">getL3CacheHitsSnoop()</a>, <a class="el" href="cpucounters_8h.html#a94118e70266db2ed7fc6b8b7b4e2c343">getL3CacheMisses()</a>, and <a class="el" href="classServerPCICFGUncore.html#a1920ef92c182c68ad433d6b2f9ae9c3d">ServerPCICFGUncore::ServerPCICFGUncore()</a>.</p>

</div>
</div>
<a class="anchor" id="ae7ce6762ad3607dbb839b6698f94697a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; PCM::getErrorMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the error message. </p>
<p>Call this when <a class="el" href="classPCM.html#a56eedaa84893f72b1723f8d580ee3329" title="Checks the status of PCM object. ">good()</a> returns false, otherwise return an empty string </p>

</div>
</div>
<a class="anchor" id="a155611028fb95409625e44784f7b4c7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPCM.html">PCM</a> * PCM::getInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <a class="el" href="classPCM.html" title="CPU Performance Monitor. ">PCM</a> object. </p>
<p>Returns <a class="el" href="classPCM.html" title="CPU Performance Monitor. ">PCM</a> object. If the <a class="el" href="classPCM.html" title="CPU Performance Monitor. ">PCM</a> has not been created before than an instance is created. <a class="el" href="classPCM.html" title="CPU Performance Monitor. ">PCM</a> is a singleton.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="classPCM.html" title="CPU Performance Monitor. ">PCM</a> object </dd></dl>

<p>Referenced by <a class="el" href="classServerPCICFGUncore.html#a007072f853bbaf5c32e56f331bf96905">ServerPCICFGUncore::computeQPISpeed()</a>, <a class="el" href="cpucounters_8h.html#a963d78be64ccddb4f7686405ef4df9c1">getActiveAverageFrequency()</a>, <a class="el" href="cpucounters_8h.html#a1f83dc2b6cd3a1efcd850003e26c6404">getAllIncomingQPILinkBytes()</a>, <a class="el" href="cpucounters_8h.html#a0b914c4bffa783271c276b29be582370">getAllOutgoingQPILinkBytes()</a>, <a class="el" href="cpucounters_8h.html#aa398facfd523b7dcdbf827a74970a88c">getAverageFrequency()</a>, <a class="el" href="cpucounters_8h.html#af8f7dab111f6b8cbcfa0c1b81e1860fb">getConsumedJoules()</a>, <a class="el" href="cpucounters_8h.html#a3641dfa6466049072b8937ee64b03738">getCoreCounterState()</a>, <a class="el" href="cpucounters_8h.html#a98aa8d4eb21e8a992fc181d65018e5ce">getCoreCStateResidency()</a>, <a class="el" href="cpucounters_8h.html#abaca7147e6334e13bbbc718e4a537568">getCoreIPC()</a>, <a class="el" href="cpucounters_8h.html#ac26765efe8a4c7341f40c8ab8bdb9af6">getCyclesLostDueL2CacheMisses()</a>, <a class="el" href="cpucounters_8h.html#a89d4cef9c83db7e76be6a0a2e7351e2e">getCyclesLostDueL3CacheMisses()</a>, <a class="el" href="cpucounters_8h.html#ab6f97a3386ac2d35dfd61148acde0a53">getDRAMConsumedJoules()</a>, <a class="el" href="cpucounters_8h.html#a0ba3a5b71b7dd6b84c345f8cbc795b1c">getIncomingQPILinkUtilization()</a>, <a class="el" href="cpucounters_8h.html#a5922acedeec3c1cc67d20670f8ef0518">getL2CacheHitRatio()</a>, <a class="el" href="cpucounters_8h.html#a459367d7877d09594c2ecd85e04cae61">getL2CacheHits()</a>, <a class="el" href="cpucounters_8h.html#a291eeab262fdb93de08cdfdf50dbad58">getL2CacheMisses()</a>, <a class="el" href="cpucounters_8h.html#a7b03f0cd02862716d717e897032b7885">getL3CacheHitRatio()</a>, <a class="el" href="cpucounters_8h.html#a7ba16714ef7ed547ad8648cb5b9e52f6">getL3CacheHits()</a>, <a class="el" href="cpucounters_8h.html#ace0e3ffc23c20d0eda7663cb7e4899a2">getL3CacheHitsNoSnoop()</a>, <a class="el" href="cpucounters_8h.html#a4b1050ca9ccdd66661df556bab70fd0f">getL3CacheHitsSnoop()</a>, <a class="el" href="cpucounters_8h.html#a94118e70266db2ed7fc6b8b7b4e2c343">getL3CacheMisses()</a>, <a class="el" href="cpucounters_8h.html#a6bdb34d102d7353421bd878da7b9ef23">getOutgoingQPILinkBytes()</a>, <a class="el" href="cpucounters_8h.html#ac7b1863133a9a711117fcb8b68d2d773">getOutgoingQPILinkUtilization()</a>, <a class="el" href="cpucounters_8h.html#a63896fb0783b57857e3ede0f24083a2a">getSocketCounterState()</a>, <a class="el" href="cpucounters_8h.html#ae6e948c5ad7859e3760336aa02f466bd">getSocketIncomingQPILinkBytes()</a>, <a class="el" href="cpucounters_8h.html#ac225ab9b4b77afb098ddefd13025d14c">getSystemCounterState()</a>, and <a class="el" href="cpucounters_8h.html#a546944a165ea621d77a524b15ccd6cf1">getTotalExecUsage()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e5450e5ce7c995410d7ac7e6e1cb1a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PCM::getMaxIPC </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the max number of instructions per cycle. </p>
<dl class="section return"><dt>Returns</dt><dd>max number of instructions per cycle </dd></dl>

</div>
</div>
<a class="anchor" id="a826a1f946b8a8d461a25ea7d11f8646e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64 PCM::getNominalFrequency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the nominal core frequency. </p>
<dl class="section return"><dt>Returns</dt><dd>Nominal frequency in Hz </dd></dl>

<p>Referenced by <a class="el" href="cpucounters_8h.html#a963d78be64ccddb4f7686405ef4df9c1">getActiveAverageFrequency()</a>, <a class="el" href="cpucounters_8h.html#aa398facfd523b7dcdbf827a74970a88c">getAverageFrequency()</a>, <a class="el" href="cpucounters_8h.html#a0ba3a5b71b7dd6b84c345f8cbc795b1c">getIncomingQPILinkUtilization()</a>, <a class="el" href="cpucounters_8h.html#a6bdb34d102d7353421bd878da7b9ef23">getOutgoingQPILinkBytes()</a>, <a class="el" href="cpucounters_8h.html#ac7b1863133a9a711117fcb8b68d2d773">getOutgoingQPILinkUtilization()</a>, <a class="el" href="classPCM.html#a794f5852662a2827b34eb16025564c70">getTickCount()</a>, and <a class="el" href="classPCM.html#a0d5153c7ec05003da7d20aeea737113e">getTickCountRDTSCP()</a>.</p>

</div>
</div>
<a class="anchor" id="ad14572fb187f2c0121843fb50f886ebd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PCM::getNumCores </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads number of logical cores in the system. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of logical cores in the system </dd></dl>

<p>Referenced by <a class="el" href="cpucounters_8h.html#a0ba3a5b71b7dd6b84c345f8cbc795b1c">getIncomingQPILinkUtilization()</a>, <a class="el" href="cpucounters_8h.html#a6bdb34d102d7353421bd878da7b9ef23">getOutgoingQPILinkBytes()</a>, and <a class="el" href="cpucounters_8h.html#ac7b1863133a9a711117fcb8b68d2d773">getOutgoingQPILinkUtilization()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e1c78309aae01a2706d1fc39766e90f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PCM::getNumSockets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads number of sockets (CPUs) in the system. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of sockets in the system </dd></dl>

<p>Referenced by <a class="el" href="cpucounters_8h.html#a1f83dc2b6cd3a1efcd850003e26c6404">getAllIncomingQPILinkBytes()</a>, <a class="el" href="cpucounters_8h.html#a0b914c4bffa783271c276b29be582370">getAllOutgoingQPILinkBytes()</a>, and <a class="el" href="classServerPCICFGUncore.html#a1920ef92c182c68ad433d6b2f9ae9c3d">ServerPCICFGUncore::ServerPCICFGUncore()</a>.</p>

</div>
</div>
<a class="anchor" id="abfe7e00fc21589083988d3f1f7b0ade3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PCM::getOriginalCPUModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads original CPU model id. </p>
<dl class="section return"><dt>Returns</dt><dd>CPU model ID </dd></dl>

</div>
</div>
<a class="anchor" id="a3b1b549672af4c14c00eb7d461c87ac4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPCIeCounterState.html">PCIeCounterState</a> PCM::getPCIeCounterState </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>socket_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the state of PCIe counter(s) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_</td><td>socket of the PCIe controller </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State of PCIe counter(s) </dd></dl>

</div>
</div>
<a class="anchor" id="ab36f29c354d85562d0492cc6688dc219"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64 PCM::getQPILinkSpeed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return QPI Link Speed in GBytes/second. </p>
<dl class="section warning"><dt>Warning</dt><dd>Works only for Nehalem-EX (Xeon 7500) and Westmere-EX (Xeon E7) processors </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>QPI Link Speed in GBytes/second </dd></dl>

<p>Referenced by <a class="el" href="cpucounters_8h.html#a0ba3a5b71b7dd6b84c345f8cbc795b1c">getIncomingQPILinkUtilization()</a>, <a class="el" href="cpucounters_8h.html#a6bdb34d102d7353421bd878da7b9ef23">getOutgoingQPILinkBytes()</a>, and <a class="el" href="cpucounters_8h.html#ac7b1863133a9a711117fcb8b68d2d773">getOutgoingQPILinkUtilization()</a>.</p>

</div>
</div>
<a class="anchor" id="acf164b6843e71199d6c26544df108799"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64 PCM::getQPILinksPerSocket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of Intel(r) Quick Path Interconnect(tm) links per socket. </p>
<dl class="section return"><dt>Returns</dt><dd>number of QPI links per socket </dd></dl>

<p>References <a class="el" href="classServerPCICFGUncore.html#ac8dc5ffa64ffebcd21b1d5882ab1fe16">ServerPCICFGUncore::getNumQPIPorts()</a>.</p>

<p>Referenced by <a class="el" href="cpucounters_8h.html#a1f83dc2b6cd3a1efcd850003e26c6404">getAllIncomingQPILinkBytes()</a>, <a class="el" href="cpucounters_8h.html#a0b914c4bffa783271c276b29be582370">getAllOutgoingQPILinkBytes()</a>, and <a class="el" href="cpucounters_8h.html#ae6e948c5ad7859e3760336aa02f466bd">getSocketIncomingQPILinkBytes()</a>.</p>

</div>
</div>
<a class="anchor" id="a9db0d472d9cdc0aa3c6db8ed7bb38f77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classServerUncorePowerState.html">ServerUncorePowerState</a> PCM::getServerUncorePowerState </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the power/energy counter state of a socket (works only on microarchitecture codename SandyBridge-EP) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State of power counters in the socket </dd></dl>

<p>References <a class="el" href="classServerPCICFGUncore.html#a3b218ad26a3c6411754ed177427b2a80">ServerPCICFGUncore::getDRAMClocks()</a>, <a class="el" href="classServerPCICFGUncore.html#ad66687e98d1b74c145b79fedefc07d15">ServerPCICFGUncore::getMCCounter()</a>, <a class="el" href="classServerPCICFGUncore.html#a52ceae2a7ca82345dbf0b9333ca12038">ServerPCICFGUncore::getNumMCChannels()</a>, <a class="el" href="classServerPCICFGUncore.html#ac8dc5ffa64ffebcd21b1d5882ab1fe16">ServerPCICFGUncore::getNumQPIPorts()</a>, <a class="el" href="classServerPCICFGUncore.html#ae5bc4e8e1003ed74fdd3c641e6ac78a5">ServerPCICFGUncore::getQPIClocks()</a>, <a class="el" href="classServerPCICFGUncore.html#a7aaff7ae03c8189de550215cef3b39f7">ServerPCICFGUncore::getQPIL0pTxCycles()</a>, and <a class="el" href="classServerPCICFGUncore.html#aa0ac63963af6105dd066f09beb923d17">ServerPCICFGUncore::getQPIL1Cycles()</a>.</p>

</div>
</div>
<a class="anchor" id="a3cb1bbca3a6ddce86dbbf8c944216710"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM::getSMT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if SMT (HyperThreading) is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>true iff SMT (HyperThreading) is enabled. </dd></dl>

</div>
</div>
<a class="anchor" id="ade00dbbd2a71ec32ae6747bfca66cd3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSocketCounterState.html">SocketCounterState</a> PCM::getSocketCounterState </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the counter state of a socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State of counters in the socket </dd></dl>

<p>Referenced by <a class="el" href="cpucounters_8h.html#a63896fb0783b57857e3ede0f24083a2a">getSocketCounterState()</a>.</p>

</div>
</div>
<a class="anchor" id="a3cf36e7c9584fc5634f190cb79ef6468"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PCM::getSocketId </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>core_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines socket of given core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">core_id</td><td>core identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>socket identifier </dd></dl>

</div>
</div>
<a class="anchor" id="a603bf92fb67f294f5bc59185bc5c89cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSystemCounterState.html">SystemCounterState</a> PCM::getSystemCounterState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the counter state of the system. </p>
<p>System consists of several sockets (CPUs). Socket has a CPU in it. Socket (CPU) consists of several (logical) cores.</p>
<dl class="section return"><dt>Returns</dt><dd>State of counters in the entire system </dd></dl>

<p>Referenced by <a class="el" href="cpucounters_8h.html#ac225ab9b4b77afb098ddefd13025d14c">getSystemCounterState()</a>.</p>

</div>
</div>
<a class="anchor" id="aaad049657e9c017c4b5840f36958b1f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PCM::getThreadsPerCore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads how many hardware threads has a physical core "Hardware thread" is a logical core in a different terminology. If Intel(r) Hyperthreading(tm) is enabled then this function returns 2. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of hardware threads per physical core </dd></dl>

<p>Referenced by <a class="el" href="cpucounters_8h.html#abaca7147e6334e13bbbc718e4a537568">getCoreIPC()</a>, and <a class="el" href="cpucounters_8h.html#a546944a165ea621d77a524b15ccd6cf1">getTotalExecUsage()</a>.</p>

</div>
</div>
<a class="anchor" id="a794f5852662a2827b34eb16025564c70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64 PCM::getTickCount </td>
          <td>(</td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>multiplier</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>core</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return TSC timer value in time units. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multiplier</td><td>use 1 for seconds, 1000 for ms, 1000000 for mks, etc (default is 1000: ms) </td></tr>
    <tr><td class="paramname">core</td><td>core to read on-chip TSC value (default is 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>time counter value </dd></dl>

<p>References <a class="el" href="classPCM.html#a4ed1c64e3cb00c76851e3373a1fa54a3">getCoreCounterState()</a>, <a class="el" href="cpucounters_8h.html#a45cf07a8d3ce2c48968842554a3854f9">getInvariantTSC()</a>, and <a class="el" href="classPCM.html#a826a1f946b8a8d461a25ea7d11f8646e">getNominalFrequency()</a>.</p>

<p>Referenced by <a class="el" href="classServerPCICFGUncore.html#a007072f853bbaf5c32e56f331bf96905">ServerPCICFGUncore::computeQPISpeed()</a>.</p>

</div>
</div>
<a class="anchor" id="a0d5153c7ec05003da7d20aeea737113e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64 PCM::getTickCountRDTSCP </td>
          <td>(</td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>multiplier</em> = <code>1000</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return TSC timer value in time units using rdtscp instruction from current core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multiplier</td><td>use 1 for seconds, 1000 for ms, 1000000 for mks, etc (default is 1000: ms) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Processor support is required bit 27 of cpuid EDX must be set, for Windows, Visual Studio 2010 is required </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>time counter value </dd></dl>

<p>References <a class="el" href="classPCM.html#a826a1f946b8a8d461a25ea7d11f8646e">getNominalFrequency()</a>.</p>

</div>
</div>
<a class="anchor" id="a56eedaa84893f72b1723f8d580ee3329"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM::good </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the status of <a class="el" href="classPCM.html" title="CPU Performance Monitor. ">PCM</a> object. </p>
<p>Call this method to check if <a class="el" href="classPCM.html" title="CPU Performance Monitor. ">PCM</a> gained access to model specific registers. The method is deprecated, see program error code instead.</p>
<dl class="section return"><dt>Returns</dt><dd>true iff access to model specific registers works without problems </dd></dl>

</div>
</div>
<a class="anchor" id="a5e4cabfe4223f1d2e7e1e0da8b1179b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool PCM::initWinRing0Lib </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads and initializes Winring0 third party library for access to processor model specific and PCI configuration registers. </p>
<dl class="section return"><dt>Returns</dt><dd>returns true in case of success </dd></dl>

</div>
</div>
<a class="anchor" id="a814c0ec41ba297581243e9c539bd38e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPCM.html#abebf5f22d794719dfc49155741e264e5">PCM::ErrorCode</a> PCM::program </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786">PCM::ProgramMode</a>&#160;</td>
          <td class="paramname"><em>mode_</em> = <code><a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786a0e861144f482697cfa423b012ed42451">DEFAULT_EVENTS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parameter_</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs performance counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode_</td><td>mode of programming, see ProgramMode definition </td></tr>
    <tr><td class="paramname">parameter_</td><td>optional parameter for some of programming modes <pre class="fragment">    Call this method before you start using the performance counting routines.
</pre></td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Using this routines with other tools that <em>program</em> Performance Monitoring Units (PMUs) on CPUs is not recommended because PMU can not be shared. Tools that are known to program PMUs: Intel(r) VTune(tm), Intel(r) Performance Tuning Utility (PTU). This code may make VTune or PTU measurements invalid. VTune or PTU measurement may make measurement with this code invalid. Please enable either usage of these routines or VTune/PTU/etc. </dd></dl>

<p>References <a class="el" href="classServerPCICFGUncore.html#a007072f853bbaf5c32e56f331bf96905">ServerPCICFGUncore::computeQPISpeed()</a>, <a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786ac092b2b5f351e33046b87e5cee31f38f">CUSTOM_CORE_EVENTS</a>, <a class="el" href="classPCM.html#a88584813a3ef51376efeb22928764786a0f2ff80b85b8f9483c7f03544f73fcbd">EXT_CUSTOM_CORE_EVENTS</a>, and <a class="el" href="classServerPCICFGUncore.html#acd6e859dd5eaaadf97d2c59ae70ac4a7">ServerPCICFGUncore::program()</a>.</p>

</div>
</div>
<a class="anchor" id="a08856dbb248f1a35a9c49799490f1734"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM::programPCIeCounters </td>
          <td>(</td>
          <td class="paramtype">const PCIeEventCode&#160;</td>
          <td class="paramname"><em>event_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program uncore PCIe monitoring event(s) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_</td><td>a PCIe event to monitor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a30cec6e4e7a78ec964d194e3844637"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPCM.html#abebf5f22d794719dfc49155741e264e5">PCM::ErrorCode</a> PCM::programServerUncorePowerMetrics </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mc_profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pcu_profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>freq_bands</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs uncore power/energy counters on microarchitectures codename SandyBridge-EP and IvyTown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mc_profile</td><td>profile for integrated memory controller PMU. See possible profile values in pcm-power.cpp example </td></tr>
    <tr><td class="paramname">pcu_profile</td><td>profile for power control unit PMU. See possible profile values in pcm-power.cpp example </td></tr>
    <tr><td class="paramname">freq_bands</td><td>array of three integer values for core frequency band monitoring. See usage in pcm-power.cpp example</td></tr>
  </table>
  </dd>
</dl>
<p>Call this method before you start using the power counter routines on microarchitecture codename SandyBridge-EP</p>
<dl class="section warning"><dt>Warning</dt><dd>After this call the memory and QPI bandwidth counters on microarchitecture codename SandyBridge-EP will not work. </dd>
<dd>
Using this routines with other tools that <em>program</em> Performance Monitoring Units (PMUs) on CPUs is not recommended because PMU can not be shared. Tools that are known to program PMUs: Intel(r) VTune(tm), Intel(r) Performance Tuning Utility (PTU). This code may make VTune or PTU measurements invalid. VTune or PTU measurement may make measurement with this code invalid. Please enable either usage of these routines or VTune/PTU/etc. </dd></dl>

<p>References <a class="el" href="classServerPCICFGUncore.html#af53af91d9172cd124e455e500d6c5622">ServerPCICFGUncore::program_power_metrics()</a>.</p>

</div>
</div>
<a class="anchor" id="ad4f5ff2c6ce12f0fb4bb5ae1e5bd157a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM::resetPMU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces PMU reset. </p>
<p>If there is no chance to free up PMU from other applications you might try to call this method at your own risk. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="cpucounters_8h_source.html">cpucounters.h</a></li>
<li>cpucounters.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 23 2014 13:47:09 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
